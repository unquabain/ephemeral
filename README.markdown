# Ephemeral

This is a little tool that allows people to share private information on public channels without having to generate and maintain key files.

## Rationale

Often times you need to send a bit of private information like a login credential or a certificate. You don't necessarily want to store this in a shared key store, because you don't want to keep it around. If the recipient has a public/private key pair in GitHub, you could use something like age (or rage) to encrypt something to them. But if they're non-technical, they probably don't.

## Protocol

The basic protocol has three parts: Request, Respond, Receive.

### Request

The Requester wants some secret information, and creates a two request documents. One Public Request and one Private Request. The Public Request can be pasted in a Slack convo or Email or any other
public text forum. The Private Request should be kept secret.

### Respond

The Responder receives the Public Request, and can use this tool to combine it with secret data to create an encrypted Response document. The Response can be shared over public channels.

### Receive

The Requester receives the Response document, and can then use this tool to combine it with their Private Request, which they have saved. The result is decrypted.

### State

The only state the application uses in any mode are:

- The Private Request file output from the Request step
- The Public Request file output from the Request step
- The Response file output from the Respond step
- The Secret file output from the Receive step

All of these documents are given to the user to manage as they will. There is no database, no memory, no cache.

## Modes of Operation

None of the modes of operation persist any hidden information.

### CLI
This tool can be used as a command line tool with subcommands for the three steps of the protocol. This is the safest and most secure way to use the tool. But, of course, if you're dealing with someone
who is comfortable using the command line, you might as well use more standard encryption tools like age or gpg.

An example session:

```
requester $ ./ephemeral request --description "What's your secret, Bruce Banner?" --private pri --public pub

responder $ echo "I'm always angry." | ./ephemeral respond --public pub --response resp --data -

requester $ ./ephemeral receive --private pri --response resp --secret -
> I'm always angry.
```

Any file can be given as `-` to indicate STDIN or STDOUT, but only one file may be specified for each channel at a time.

The `help` command lists the available options:

```
./ephemeral help receive
Pairs the secret request (generated by the request subcommand)
with the encrypted response (generated by the respond subcommand) and
decrypts the secret.

Usage:
  ephemeral receive [flags]

Flags:
  -h, --help              help for receive
  -v, --private string    The name of the private request file to be used to decode the response. (default "request_private.txt")
  -r, --response string   The file the response was written to. (default "-")
  -s, --secret string     Where to write the decrypted, secret data. (default "-")

Global Flags:
  -g, --debug   Turn on verbose logging.
```

#### Completion

The command includes a completion function for several shells.

```
source <( ./ephemeral completion zsh )
```

For a list and instructions, type:

```
./ephemeral help completion
# and, e.g.
./ephemeral help completion powershell
```

### Web
The tool will also run a web server that offers two flows that offer guidance to a non-technical user.

### Full Web Flow

The page served at /full offers full instructions for each of the three protocol steps. The documents created and consumed by this flow are compatible with the CLI usage.

### Short Web Flow

The page at / offers an abbreviated flow for users who need less assistance. It doesn't require the requester to save any Private Request file, but it does this by offering them a link to the Receive page. So this method is less suitable for non-synchronous interactions like email, or with people in other timezones.

The documents prepared by the Short web flow have less metadata, and are not compatible with the Full web flow or the CLI usage.
